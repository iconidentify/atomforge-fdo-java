package com.atomforge.fdo;

import com.atomforge.fdo.model.FdoAtom;
import com.atomforge.fdo.model.FdoStream;
import com.atomforge.fdo.model.FdoValue;
import org.junit.jupiter.api.Named;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for FDO files in replace_fdos directory.
 *
 * <p>These tests verify:
 * <ol>
 *   <li>Our Java compiler produces identical binary to Ada32.dll</li>
 *   <li>Round-trip through FdoStream (source -> binary -> FdoStream -> binary) produces identical bytes</li>
 * </ol>
 *
 * <p>Reference binaries were generated by calling the Ada32 HTTP API at http://i9beef:8000/compile
 */
class ReplaceFdosTest {

    private static final String RESOURCE_BASE = "replace_fdos/";

    /**
     * Provides test cases for FDO files in replace_fdos directory.
     */
    static Stream<Named<String>> provideFdoFiles() {
        return Stream.of(
            Named.of("sample_001.bw", "sample_001.bw"),
            Named.of("sample_002", "sample_002"),
            Named.of("sample_003.bw", "sample_003.bw"),
            Named.of("sample_004", "sample_004"),
            Named.of("sample_005.bw", "sample_005.bw"),
            Named.of("sample_006", "sample_006"),
            Named.of("sample_007", "sample_007"),
            Named.of("sample_008.bw", "sample_008.bw"),
            Named.of("sample_009", "sample_009"),
            Named.of("sample_010", "sample_010"),
            Named.of("sample_011", "sample_011"),
            Named.of("sample_012", "sample_012"),
            Named.of("sample_013", "sample_013"),
            Named.of("sample_014", "sample_014")
        );
    }

    /**
     * Test that our compiler produces identical binary to Ada32.dll.
     */
    @ParameterizedTest(name = "{0}")
    @MethodSource("provideFdoFiles")
    void testCompilationMatchesAda32(String baseName) throws FdoException, IOException {
        // Load FDO source
        String source = loadTextResource(RESOURCE_BASE + baseName + ".fdo.txt");

        // Load Ada32 reference binary
        byte[] expected = loadBinaryResource(RESOURCE_BASE + "bin/" + baseName + ".bin");

        // Compile with our Java implementation
        FdoCompiler compiler = FdoCompiler.create();
        byte[] actual = compiler.compile(source);

        // Compare
        if (!java.util.Arrays.equals(expected, actual)) {
            int diffIndex = findFirstDifference(expected, actual);
            String context = formatDiffContext(expected, actual, diffIndex);

            fail(String.format(
                "[%s] Binary mismatch at byte %d (0x%04X)%n" +
                "Expected length: %d bytes%n" +
                "Actual length: %d bytes%n%n" +
                "Context around difference:%n%s",
                baseName, diffIndex, diffIndex, expected.length, actual.length, context
            ));
        }
    }

    /**
     * Test semantic round-trip through FdoStream object model.
     *
     * <p>Verifies: source -> compile -> FdoStream.decode -> FdoStream.toBytes -> decode again -> same atoms
     *
     * <p>Note: Byte-for-byte round-trip is NOT guaranteed because FdoStream.toBytes() uses FULL
     * encoding style while Ada32 uses compact styles. The output is semantically equivalent
     * but may be longer.
     */
    @ParameterizedTest(name = "{0}")
    @MethodSource("provideFdoFiles")
    void testSemanticRoundTripThroughFdoStream(String baseName) throws FdoException, IOException {
        // Load FDO source
        String source = loadTextResource(RESOURCE_BASE + baseName + ".fdo.txt");

        // Compile to binary
        FdoCompiler compiler = FdoCompiler.create();
        byte[] compiled = compiler.compile(source);

        // Decode to FdoStream object model
        FdoStream stream1 = FdoStream.decode(compiled);

        // Re-encode back to binary
        byte[] roundTripped = stream1.toBytes();

        // Decode the round-tripped binary
        FdoStream stream2 = FdoStream.decode(roundTripped);

        // Compare atom counts
        assertEquals(stream1.size(), stream2.size(),
            String.format("[%s] Atom count mismatch after round-trip", baseName));

        // Compare each atom semantically
        for (int i = 0; i < stream1.size(); i++) {
            var atom1 = stream1.get(i);
            var atom2 = stream2.get(i);

            assertEquals(atom1.name(), atom2.name(),
                String.format("[%s] Atom %d name mismatch", baseName, i));
            assertEquals(atom1.protocol(), atom2.protocol(),
                String.format("[%s] Atom %d protocol mismatch", baseName, i));
            assertEquals(atom1.atomNumber(), atom2.atomNumber(),
                String.format("[%s] Atom %d number mismatch", baseName, i));

            // Compare values semantically (handles RawValue byte arrays and nested streams)
            assertTrue(valuesEqual(atom1.value(), atom2.value()),
                String.format("[%s] Atom %d (%s) value mismatch", baseName, i, atom1.name()));
        }
    }

    /**
     * Compare two FdoValue instances for semantic equality.
     * Handles RawValue byte arrays and nested StreamValues properly.
     */
    private boolean valuesEqual(FdoValue v1, FdoValue v2) {
        if (v1.getClass() != v2.getClass()) {
            return false;
        }

        if (v1 instanceof FdoValue.RawValue r1 && v2 instanceof FdoValue.RawValue r2) {
            return java.util.Arrays.equals(r1.data(), r2.data());
        }

        if (v1 instanceof FdoValue.StreamValue s1 && v2 instanceof FdoValue.StreamValue s2) {
            FdoStream stream1 = s1.stream();
            FdoStream stream2 = s2.stream();
            if (stream1.size() != stream2.size()) {
                return false;
            }
            for (int i = 0; i < stream1.size(); i++) {
                FdoAtom a1 = stream1.get(i);
                FdoAtom a2 = stream2.get(i);
                if (!a1.name().equals(a2.name()) ||
                    a1.protocol() != a2.protocol() ||
                    a1.atomNumber() != a2.atomNumber() ||
                    !valuesEqual(a1.value(), a2.value())) {
                    return false;
                }
            }
            return true;
        }

        // For other value types, use equals()
        return v1.equals(v2);
    }

    // ========== Helper Methods ==========

    private String loadTextResource(String path) throws IOException {
        try (InputStream is = getClass().getClassLoader().getResourceAsStream(path)) {
            if (is == null) {
                throw new IOException("Resource not found: " + path);
            }
            return new String(is.readAllBytes(), StandardCharsets.UTF_8);
        }
    }

    private byte[] loadBinaryResource(String path) throws IOException {
        try (InputStream is = getClass().getClassLoader().getResourceAsStream(path)) {
            if (is == null) {
                throw new IOException("Resource not found: " + path);
            }
            return is.readAllBytes();
        }
    }

    private int findFirstDifference(byte[] expected, byte[] actual) {
        int minLen = Math.min(expected.length, actual.length);
        for (int i = 0; i < minLen; i++) {
            if (expected[i] != actual[i]) {
                return i;
            }
        }
        return minLen; // Difference is length mismatch
    }

    private String formatDiffContext(byte[] expected, byte[] actual, int diffIndex) {
        StringBuilder sb = new StringBuilder();

        int start = Math.max(0, diffIndex - 8);
        int endExpected = Math.min(expected.length, diffIndex + 16);
        int endActual = Math.min(actual.length, diffIndex + 16);

        sb.append(String.format("Expected (bytes %d-%d):%n", start, endExpected - 1));
        sb.append(formatHexLine(expected, start, endExpected, diffIndex));
        sb.append("\n");

        sb.append(String.format("Actual (bytes %d-%d):%n", start, endActual - 1));
        sb.append(formatHexLine(actual, start, endActual, diffIndex));

        return sb.toString();
    }

    private String formatHexLine(byte[] data, int start, int end, int highlight) {
        StringBuilder sb = new StringBuilder();
        for (int i = start; i < end; i++) {
            if (i == highlight) {
                sb.append("[");
            }
            sb.append(String.format("%02x", data[i] & 0xFF));
            if (i == highlight) {
                sb.append("]");
            }
            sb.append(" ");
        }
        return sb.toString();
    }
}
